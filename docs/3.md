### Redis 缓存

#### Redis 各版本特性
* 2.8：scan指令、HyperLogLog
* 3.2：Geo
* 4.0：Redis-Cell、布隆过滤器、惰性删除(unlink/flushall async)、异步删除点(rename指令、key过期、LRU淘汰)

#### redis 数据结构
1. String、Hash、List、Set、ZSet
1. 位图：单key存储不能超过512M，即offset最多2^32，存储计算：(offset/8/1024/1024)MB。
1. 订阅：订阅者需要阻塞的读，下线期间数据是丢失的（redis 5.0能持久化）
1. Geo：实现附近的人的功能
1. Redis-Cell：分布式限流模块
1. HyperLogLog：有误差的统计uv等，pfadd、pfcount。不能作布隆过滤器，因为如果判断不存在就加入集合了。
1. 布隆过滤器：False is always false

#### redis 优化经验
1. [Redis优化经验](https://www.cnblogs.com/duanxz/p/5447402.html)
1. list、hash、set、zset 的元素个数不超过8192，value大小不超过1MB

####  redis 实现队列有什么优点和缺点
1. 优点：实现简单（LPUSH+BRPOP），可持久化，保证顺序
1. 缺点：不能重复消费，消费确认ACK麻烦(需要额外支持)，不支持广播模式

#### 单 key 不宜超过 1MB
1. [Redis 深度历险：核心原理与应用实践](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b3d97d9e51d4519634f8512)
1. 有三个原因：
  * 在集群环境中，key 太大会导致数据迁移卡顿
  * 内存分配时，扩容需要申请更大的内存，也会导致卡顿
  * 被删除时，内存会被一次性回收，也会卡顿
1. redis-cli -h 127.0.0.1 -p 7001 –-bigkeys -i 0.1，查找大 key 每隔 100 条 scan 指令就会休眠 0.1s，ops 就不会剧烈抬升

### redis 的进程和线程
1. [Redis的多线程与多进程](https://blog.csdn.net/yinyuehepijiu/article/details/50408988)
1. redis 数据处理是单进程单线程的。单线程的好处：cpu不是瓶颈、线程切换有开销、多线程有锁的问题。
1. redis 的另外2个子进程：
  1. 子进程写快照rdb，用到了多进程的COW原理（子进程和父进程共享内存，修改的时候clone修改的部分再修改）
  1. 子进程AOF日志重写：直接基于内存转换成新的AOF日志，同时补上转换期间的增量日志，生成完后替换掉旧的AOF日志。
1. redis 另外的线程：
  1. 日志线程
  1. AOF日志不是实时写入磁盘的，是定时1s，[Redis AOF 持久化- Redis源码分析](https://gsmtoday.github.io/2018/07/30/redis-01/)

#### rdb 和 aof 过程？rdb 为什么可以用创建子进程的方式进行？（这里考察一个 cow）这两种持久化方式会丢数据吗？
1. https://www.cnblogs.com/itdragon/p/7906481.html

#### redis 为什么快？（主要考察一个 IO 多路复用和单线程不加锁）
1. 纯内存
1. 非阻塞IO
1. 避免线程切换和竞争消耗

#### 一致性哈希是什么？节点较少时数据分布不均匀怎么办？
1. 定义：在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。
1. 节点较少时，每个节点多虚拟一个hash槽点。

#### 简单说下几种 key 的淘汰策略，redis 里的 lru 算法，什么时候会触发？实现细节是什么？怎么保证淘汰合理的 key？
1. 定时过期：每个设置过期时间的 Key 创建定时器，到过期时间立即清除。内存友好，CPU 不友好
1. 惰性过期：访问 Key 时判断是否过期，过期则清除。CPU 友好，内存不友好
1. 定期过期：隔一定时间，expires 字典中扫描一定数量的 Key，清除其中已过期的 Key。内存和 CPU 资源达到最优的平衡效果

#### 缓存击穿 / 穿透 / 雪崩的处理策略

#### Redis 的同步机制
主从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。





