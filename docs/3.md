### Redis 缓存

#### Redis 各版本特性
* 2.8：scan指令、HyperLogLog
* 3.2：Geo
* 4.0：
  1. Redis-Cell
  1. 布隆过滤器
  1. AOF sync到硬盘
  1. 惰性删除(unlink/flushall async)
  1. 异步删除点(rename指令、key过期、LRU淘汰)
  1. 混合持久化

#### redis 数据结构
1. String、Hash、List、Set、ZSet
1. 位图：单key存储不能超过512M，即offset最多2^32，存储计算：(offset/8/1024/1024)MB。
1. 订阅：订阅者需要阻塞的读，下线期间数据是丢失的（redis 5.0能持久化）
1. Geo：实现附近的人的功能
1. Redis-Cell：分布式限流模块
1. HyperLogLog：有误差的统计uv等，pfadd、pfcount。不能作布隆过滤器，因为如果判断不存在就加入集合了。
1. 布隆过滤器：False is always false

#### redis 优化经验
1. [Redis优化经验](https://www.cnblogs.com/duanxz/p/5447402.html)
1. list、hash、set、zset 的元素个数不超过8192，value大小不超过1MB

####  redis 实现队列有什么优点和缺点
1. 优点：实现简单（LPUSH+BRPOP），可持久化，保证顺序
1. 缺点：不能重复消费，消费确认ACK麻烦(需要额外支持)，不支持广播模式

#### 单 key 不宜超过 1MB
1. [Redis 深度历险：核心原理与应用实践](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b3d97d9e51d4519634f8512)
1. 有三个原因：
  * 在集群环境中，key 太大会导致数据迁移卡顿
  * 内存分配时，扩容需要申请更大的内存，也会导致卡顿
  * 被删除时，内存会被一次性回收，也会卡顿
1. redis-cli -h 127.0.0.1 -p 7001 –-bigkeys -i 0.1，查找大 key 每隔 100 条 scan 指令就会休眠 0.1s，ops 就不会剧烈抬升

### redis 的进程和线程
1. [Redis的多线程与多进程](https://blog.csdn.net/yinyuehepijiu/article/details/50408988)
1. redis 数据处理是单进程单线程的。单线程的好处：cpu不是瓶颈、线程切换有开销、多线程有锁的问题。
1. redis 的另外2个子进程：
  1. 子进程写快照rdb，用到了多进程的COW原理（子进程和父进程共享内存，修改的时候clone修改的部分再修改）
  1. 子进程AOF日志重写：直接基于内存转换成新的AOF日志，同时补上转换期间的增量日志，生成完后替换掉旧的AOF日志。
1. redis 另外的线程：
  1. 日志线程
  1. AOF日志不是实时写入磁盘的，是定时1s，[Redis AOF 持久化- Redis源码分析](https://gsmtoday.github.io/2018/07/30/redis-01/)

#### rdb 和 aof 过程
1. https://www.cnblogs.com/itdragon/p/7906481.html
1. rdb是定时备份快照到dump.rdb，以子进程的cow的方式。配置文件：save 900 1表示900秒内有1个key更新就触发。
1. aof是先实时记录到aof_buf(内存)，写到磁盘的appendonly.aof取决于配置文件：
   1. appendfsync everysec，定时一秒写入AOF文件，(4.0后单独线程处理)
   1. appendfsync always，实时写入AOF文件
   1. appendfsync no，同步时间不确定
1. aof重写：也是定时
   1. 以子进程重新生成整个aof文件，并压缩
   1. 同时写aof_buf和aof_rewrite_buf
   1. 生成完aof文件后追加aof_rewrite_buf，并替换老的aof文件
1. 4.0后混合持久化，先rdb恢复，再aof恢复

#### redis 为什么快？（主要考察一个 IO 多路复用和单线程不加锁）
1. 纯内存
1. 非阻塞IO
1. 避免线程切换和竞争消耗

#### 一致性哈希是什么？节点较少时数据分布不均匀怎么办？
1. 定义：在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。
1. 节点较少时，每个节点多虚拟一个hash槽点。

#### 简单说下几种 key 的淘汰策略，redis 里的 lru 算法，什么时候会触发？实现细节是什么？怎么保证淘汰合理的 key？
1. 定时过期：每个设置过期时间的 Key 创建定时器，到过期时间立即清除。内存友好，CPU 不友好
1. 惰性过期：访问 Key 时判断是否过期，过期则清除。CPU 友好，内存不友好
1. 定期过期：隔一定时间，expires 字典中扫描一定数量的 Key，清除其中已过期的 Key。内存和 CPU 资源达到最优的平衡效果

#### Redis 底层数据结构
1. [Redis 设计与实现](http://redisbook.com/)
1. [图解redis五种数据结构底层实现](https://i6448038.github.io/2019/12/01/redis-data-struct/)
1. String，整型直接用long，其他用【sds】（小字符串用embstr编码，大字符串用raw）
1. Hash，单值长度>64或者元素数量>512，用【hashtable】，否则用【ziplist】
1. List，单值长度>64或者元素数量>512，用【linkedlist】或【quicklist】，否则用【ziplist】
1. Zset，单值长度>64或者元素数量>128，用【skiplist】，否则用【ziplist】
1. Set，元素都是整型或者元素数量<=512，用【intset】，否则用【hashtable】
1. 【sds】，对比C的【String】，获取字符串长度复杂度为O(1)；不会造成缓冲区溢出
1. 【ziplist】，为节约内存而开发的顺序型数据结构，内存是连续的
1. 【hashtable】，两个哈希表，ht[1]只在对ht[0]进行rehash的时候使用
1. 【linkedlist】，双端链表
1. 【quicklist】，【linkedlist】和【ziplist】的结合。因为【linkedlist】指针占空间。
1. 【intset】，底层实现为数组，有序、无重复的方式保存元素
1. 【skiplist】，对比B+树，实现简单

#### Redis 的同步机制
主从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。





