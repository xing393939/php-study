### 架构

#### 分布式架构的理论
1. [从0开始学架构](https://time.geekbang.org/column/article/6354)
1. 软件的复杂度：高性能(榨干单机、集群)、高可用、可扩展性(设计模式的思想)，此外还有低成本、安全、规模。
1. 架构设计三原则：合适原则、简单原则、演化原则。合适优于先进，演化优于一步到位，简单优于复杂。
1. 高性能：读写分离、分库分表(或业务分库)、NoSql(文档数据库、列式数据库、全文搜索)、使用缓存。
 * 缓存雪崩：缓存大量失效导致数据库压力过大崩溃继而导致整个系统崩溃，方案1是更新锁，方案2是后台异步更新缓存。
 * 单机高性能：多进程多线程。多线程开销少、线程通信简单，但是线程之间容易死锁、某个线程异常可能导致整个进程退出。
1. 负载均衡：region级别用DNS，同机房集群用硬件F5，机器级别用nginx或lvs。
1. 异地多活：异地就是多个地理位置，多活就是多个地理位置都能提供服务。
1. 故障应对：降级(保住主业务)、熔断(熔断故障点以免拖慢系统)、限流和排队(牺牲了一定的用户体验)
1. 选主算法：ZAB(ZooKeeper)、Paxos、Raft(etcd、Redis-Cluster)、Gossip(Redis-Cluster、Redis-Sentinel、Consul)

#### 单机高性能
1. [从0开始学架构](https://time.geekbang.org/column/article/6354)
1. bio：阻塞io，PPC和TPC属于这种(一个连接一个进程/线程)。假如我们去饭店点餐，饭店人很多，如果我们付了钱后站在收银台等着饭端上来我们才离开，这就成了同步阻塞了。
1. nio：多路复用io，Reactor就是基于这种技术。如果我们付了钱后给你一个号就可以离开，饭好了老板会叫号，你过来取。这就是Reactor模型。
1. aio：异步io，Proactor就是基于这种技术。如果我们付了钱后给我一个号就可以坐到坐位上该干啥干啥，饭好了老板会把饭端上来送给你。这就是Proactor模型了。
1. 单Reactor单进程的是Redis；多Reactor多进程的是Nginx；多Reactor多线程的是Memcache和Netty。

#### 亿级 pv 网站架构
1. [PHP进阶之路](https://segmentfault.com/ls/1650000011318558)
1. 分离：动静分离、读写分离、业务分离，微服务化
1. 分层：业务分层，多级缓存
1. 分布：分布式数据库，分布式缓存，分布式存储，分布式计算
1. 服务发现：服务者-注册中心-消费者-监控中心，除此之外还需要服务治理：增删节点，权重规则，路由配置，调的服务尽量落在统一机房
 * 客户端发现模式：带负载调度规则的客户端SDK，这种比较常用
 * 服务端发现模式：在消费者和服务者中间加一个负载均衡器，由负载均衡器去调度。

#### 常见概念
1. [左耳听风-分布式架构入门](https://time.geekbang.org/column/article/10603)
1. CAP：现实中 P 很少遇到，而 C 和 A 放宽约束后可以兼顾一致性和可用性，两者不是非此即彼。
1. BASE：最终一致性。为了可用性牺牲部分一致性可以显著地提升系统的可伸缩性。
 * Basically Available(基本可用)：出现故障时响应时间变长、部分用户功能不正常
 * Soft State(软状态)：相对于原子性而言，所有数据副本都是一致的，这是硬状态。软状态则有数据副本不一致的时候。
 * Consistent(最终一致性)：软状态在某个时间期限后，所有数据副本都是一致的。
1. 分布式一致性算法：
 * Paxos(号称是最难理解的算法)、
 * Raft(Paxos算法的一种简化实现)、
 * ZAB(基于Paxos算法)
 * Gossip(又称流言算法、疫情传播算法。只有大多数节点都认定某个节点失联了，集群才认为是失联了)



